import chainlit as cl
import dotenv
import os

# text delta: changes in the text
# When response text is changed, new tocken is added to the output
# It helps to catch the changes in the LLM output mechanism
from openai.types.responses import ResponseTextDeltaEvent
from agents import Runner, SQLiteSession
from nutrition_agent import nutrition_agent

dotenv.load_dotenv()

@cl.on_chat_start
async def on_chat_start():
    session = SQLiteSession("converstaion_history")
    cl.user_session.set("agent_session", session)

@cl.on_message
async def on_message(message: cl.Message):
    session = cl.user_session.get("agent_session")

    # Output is streamed. It is needed to catch every change in the output.
    result = Runner.run_streamed(
        starting_agent=nutrition_agent,
        input=message.content,
        session=session
    )

    # message created
    msg = cl.Message(content="")
    # iteration through all events from LLM
    async for event in result.stream_events():
        # Stream final message text to screen
        # if block to catch the output token generated by LLM
        # event type must be 'raw_response_event' and event data must be an instance of ResponseTextDeltaEvent
        if event.type == "raw_response_event" and isinstance(event.data, ResponseTextDeltaEvent):
            # whenever there is a new content, it is streamed back to the ui.
            await msg.stream_token(token=event.data.delta)
            # output is written also into console for debugging purpose.
            print(event.data.delta, end="", flush=True)
        # elif block to catch tool function calls
        elif (
            event.type == "raw_response_event"
            and hasattr(event.data, "item")
            and hasattr(event.data.item, "type")
            and event.data.item.type == "function_call"
            and len(event.data.item.arguments) > 0
        ):
            # with chainlit.Step, status is added to the response.
            with cl.Step(name=f"{event.data.item.name}", type="tool") as step:
                step.input = event.data.item.arguments
                # debugging print out
                print(f"\nTool call: {event.data.item.name} with args: {event.data.item.arguments}")

    # to close the message
    await msg.update()

@cl.password_auth_callback
def auth_callback(username: str, password: str):
    if (username, password) == (
        os.getenv("CHAINLIT_USERNAME"),
        os.getenv("CHAINLIT_PASSWORD"),
    ):
        return cl.User(
            identifier="Student",
            metadata={"role": "student", "provider": "credentials"},
        )
    else:
        return None
